<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <!-- Google Search Console Verification -->
    <meta name="google-site-verification" content="rxsUTugt_BB2D2dTbHu7H0G0pvs1EYy8EgVLDM7LuVQ" />

    <!-- Primary SEO Tags -->
    <title>Free PDF Merger No Sign Up - Merge PDFs Online Free | Private & Secure</title>
    <meta name="description" content="Free PDF merger with no sign up required. Merge PDF files online for free in seconds. No upload - your files stay 100% private on your device. Unlimited use, no watermarks, works on any device.">
    <meta name="keywords" content="free pdf merger no sign up, merge pdf free no sign up, pdf merger free no sign up, pdf combiner free no sign up, merge pdf, combine pdf, pdf merger, free pdf merger, merge pdf files, combine pdf files, pdf combiner, join pdf, pdf joiner, no signup, no registration, privacy, secure pdf merger, local pdf processing, offline pdf merger, browser pdf tool, free online pdf tool">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Free PDF Merger No Sign Up - 100% Private in Your Browser">
    <meta property="og:description" content="Merge PDF files instantly in your browser with a free PDF merger, no sign up required. No upload to servers - completely private and secure.">
    <meta property="og:url" content="https://freemergepdf.com">
    <meta property="og:image" content="https://freemergepdf.com/og-image.png">

    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Free PDF Merger No Sign Up - 100% Private in Your Browser">
    <meta name="twitter:description" content="Merge PDF files instantly in your browser with a free PDF merger, no sign up required. No upload to servers - completely private.">
    <meta name="twitter:image" content="https://freemergepdf.com/og-image.png">
    
    <!-- Additional SEO -->
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="author" content="PDF Merger Tool">
    <link rel="canonical" href="https://freemergepdf.com">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Free PDF Merger",
      "description": "Free online tool to merge PDF files locally in your browser without signup or file upload",
      "applicationCategory": "UtilityApplication",
      "operatingSystem": "Any",
      "url": "https://freemergepdf.com",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "featureList": "No signup, No registration, Private processing, Local file handling, Free to use, Secure, Unlimited documents, Drag-and-drop reordering"
    }
    </script>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKQQKSRNPJ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FKQQKSRNPJ');
    </script>
    
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>

    <!-- Advanced PDF Merger CSS -->
    <link rel="stylesheet" href="advanced-pdf-merger.css">
    <link rel="stylesheet" href="feedback.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 14px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 26px 24px 28px;
            max-width: 900px;
            width: 100%;
            margin-top: 12px;
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 0;
            line-height: 1.05;
            text-align: center;
        }

        .subtitle {
            color: #666;
            text-align: center;
            margin-bottom: 16px;
            font-size: 13px;
        }

        .hero-note {
            margin-top: -2px;
            margin-bottom: 0;
            font-size: 13px;
            color: #555;
            text-align: center;
        }

        .hero-note summary {
            cursor: pointer;
            list-style: none;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            justify-content: center;
            padding: 0;
            margin: 0;
        }

        .hero-note summary::-webkit-details-marker {
            display: none;
        }

        .hero-note summary::after {
            content: '+';
            font-weight: 600;
            font-size: 14px;
        }

        .hero-note[open] summary::after {
            content: '-';
        }

        .hero-note p {
            margin-top: 6px;
            line-height: 1.4;
        }

        .hero-inline {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .hero-inline .hero-note {
            margin: 0;
        }

        /* Collapsible wrappers to keep SEO text present but tucked away */
        .seo-accordions {
            width: 100%;
            max-width: 900px;
            margin: 32px auto;
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .seo-accordion {
            width: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            background: #fff;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .seo-accordion + .seo-accordion {
            border-top: 0;
        }

        .seo-accordion summary {
            padding: 14px 16px;
            font-weight: 600;
            cursor: pointer;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f7f7fb;
            min-height: 48px;
        }

        .seo-accordion summary::-webkit-details-marker {
            display: none;
        }

        .seo-accordion summary::after {
            content: '+';
            margin-left: auto;
            font-size: 18px;
            line-height: 1;
        }

        .seo-accordion[open] summary::after {
            content: '-';
        }

        .seo-accordion-body {
            padding: 16px;
            background: #fff;
        }

        /* ===== SIMPLE MODE ===== */
        .mode-simple {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mode-simple.hidden {
            display: none;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }

        .file-input-wrapper {
            display: flex;
            flex-direction: column;
        }

        .file-input-label {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .file-input-group {
            position: relative;
            cursor: pointer;
        }

        .file-input-group input[type="file"] {
            display: none;
        }

        .file-input-display {
            padding: 20px;
            border: 2px dashed #667eea;
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s ease;
            background: #f8f9fa;
            cursor: pointer;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .file-input-display:hover {
            border-color: #764ba2;
            background: #f0f0ff;
        }

        .file-input-display.has-file {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .file-input-display.upload-error-glow,
        .drop-zone.upload-error-glow {
            border-color: #e24b4b;
            animation: uploadErrorGlow 0.9s ease;
        }

        @keyframes uploadErrorGlow {
            0% {
                box-shadow: 0 0 0 0 rgba(226, 75, 75, 0);
            }
            35% {
                box-shadow: 0 0 0 4px rgba(226, 75, 75, 0.35), 0 0 18px rgba(226, 75, 75, 0.5);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(226, 75, 75, 0);
            }
        }

        .file-input-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .file-input-text {
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
        }

        .file-input-subtext {
            color: #999;
            font-size: 12px;
            margin-top: 5px;
        }

        .file-name {
            color: #333;
            font-weight: 600;
            margin-top: 10px;
            word-break: break-word;
            font-size: 15px;
        }

        .file-size {
            color: #999;
            font-size: 14px;
            margin-top: 5px;
        }

        .file-clear-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 13px;
            margin-top: 8px;
            text-decoration: underline;
            transition: color 0.2s;
            padding: 0;
        }

        .file-clear-btn:hover {
            color: #667eea;
        }

        .expand-section {
            text-align: center;
            padding: 20px 0;
            margin-top: 20px;
        }

        /* ===== SIMPLE MODE REORGANIZED ===== */
        
        .simple-merge-section {
            padding: 0;
            text-align: center;
            margin: 20px 0 0 0;
        }

        .merge-btn-large {
            width: 100%;
            padding: 20px 40px !important;
            font-size: 18px !important;
            letter-spacing: 0.5px;
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4) !important;
            margin-bottom: 2px !important;
        }

        .merge-btn-large:hover:not(:disabled) {
            transform: translateY(-3px) !important;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5) !important;
        }

        .merge-btn-large:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .simple-merge-hint {
            color: #999;
            font-size: 13px;
            margin-top: 2px;
            margin-bottom: 0;
            font-style: italic;
        }

        .simple-options-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
            margin-top: 2px;
        }

        .simple-options-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 14px 15px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .simple-options-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .simple-options-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .expand-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            color: white !important;
            border: none !important;
        }

        .expand-btn:hover:not(:disabled) {
            transform: translateY(-2px) !important;
            box-shadow: 0 6px 16px rgba(245, 158, 11, 0.4) !important;
        }

        @media (max-width: 768px) {
            .simple-options-section {
                grid-template-columns: 1fr;
            }
        }

        /* ===== FILENAME INPUT (NEW) ===== */
        .filename-input-row {
            margin-top: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #555;
            grid-column: 1 / -1;
        }

        .filename-input-row input {
            padding: 6px 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 13px;
            width: 230px;
        }

        /* ===== EXPANDED MODE ===== */
        .mode-expanded {
            display: none;
        }

        .mode-expanded.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mode-toggle-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        .back-to-simple {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            text-decoration: underline;
            font-size: 14px;
            transition: color 0.2s;
        }

        .back-to-simple:hover {
            color: #764ba2;
        }

        .mode-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            flex: 1;
        }

        .document-count {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }

        .drop-zone {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }

        .drop-zone:hover {
            border-color: #764ba2;
            background: #f0f0ff;
        }

        .drop-zone.dragover {
            border-color: #764ba2;
            background: #e0e7ff;
            transform: scale(1.02);
        }

        .drop-zone-text {
            color: #667eea;
            font-weight: 600;
            font-size: 16px;
        }

        .drop-zone-subtext {
            color: #999;
            font-size: 14px;
            margin-top: 8px;
        }

        .drop-zone input[type="file"] {
            display: none;
        }

        .pdf-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .pdf-card {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: grab;
            transition: all 0.2s ease;
        }

        .pdf-card.pdf-card-invalid {
            border-color: #f5c6cb;
            background: #fdf2f3;
        }

        .pdf-card.pdf-card-invalid .pdf-name,
        .pdf-card.pdf-card-invalid .pdf-size {
            color: #8b2b2f;
        }

        .pdf-issue {
            margin-top: 6px;
            font-size: 12px;
            font-weight: 600;
            color: #b2343b;
        }

        .pdf-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .pdf-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .drag-handle {
            color: #999;
            cursor: grab;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            flex-shrink: 0;
        }

        .pdf-card.dragging .drag-handle {
            cursor: grabbing;
        }

        .pdf-order {
            background: #667eea;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .pdf-info {
            flex: 1;
            min-width: 0;
        }

        .pdf-name {
            font-weight: 600;
            color: #333;
            word-break: break-word;
            font-size: 15px;
        }

        .pdf-size {
            color: #999;
            font-size: 13px;
            margin-top: 4px;
        }

        .pdf-delete {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 20px;
            padding: 5px;
            flex-shrink: 0;
            transition: color 0.2s;
        }

        .pdf-delete:hover {
            color: #ff4757;
        }

        .add-more-section {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px dashed #ddd;
        }

        .add-more-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            text-decoration: underline;
            transition: color 0.2s;
        }

        .add-more-btn:hover {
            color: #764ba2;
        }

        /* ===== BUTTONS ===== */
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .merge-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .merge-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .merge-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .merge-btn.loading {
            position: relative;
            color: transparent;
        }

        .merge-btn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .memory-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 12px 15px;
            color: #856404;
            font-size: 13px;
            margin-top: 15px;
            display: none;
        }

        .memory-warning.show {
            display: block;
        }

        .error-message {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 12px 15px;
            color: #721c24;
            font-size: 14px;
            margin-top: 15px;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        .error-action {
            display: none;
            margin-top: 8px;
        }

        .error-action.show {
            display: block;
        }

        .error-action-btn {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 600;
        }

        .error-action-btn:hover {
            background: #f3c8cd;
        }

        .status-area {
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-ready {
            background: #e0e7ff;
            color: #4c51bf;
        }

        .status-processing {
            background: #fef3c7;
            color: #d97706;
        }

        .status-success {
            background: #d1fae5;
            color: #059669;
        }

        .status-error {
            background: #fee2e2;
            color: #dc2626;
        }

        .affiliate-inline {
            font-size: 12px;
            color: #6b7280;
        }

        .affiliate-inline a {
            color: #4f46e5;
            font-weight: 600;
            text-decoration: none;
        }

        .affiliate-inline a:hover {
            color: #4338ca;
            text-decoration: underline;
        }

        /* ===== FEATURES & FAQ ===== */
        .features {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 900px;
            width: 100%;
            margin-top: 20px;
        }

        .features h2 {
            color: #333;
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            color: #555;
            margin-bottom: 15px;
            padding-left: 30px;
            position: relative;
            line-height: 1.6;
        }

        .feature-list li:before {
            content: "‚úì";
            position: absolute;
            left: 0;
            color: #667eea;
            font-weight: bold;
            font-size: 18px;
        }

        .seo-content {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 900px;
            width: 100%;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .seo-content h2 {
            color: #333;
            font-size: 22px;
            margin-bottom: 15px;
        }

        .seo-content p {
            color: #555;
            line-height: 1.8;
            margin-bottom: 15px;
        }

        .seo-content h3 {
            color: #333;
            font-size: 18px;
            margin-top: 25px;
            margin-bottom: 10px;
        }

        .footer-links {
            text-align: center;
            padding: 20px;
            color: white;
        }

        .footer-links a {
            color: white;
            text-decoration: none;
            margin: 0 15px;
        }

        .footer-links a:hover {
            text-decoration: underline;
        }

        .footer-separator {
            color: white;
        }
    </style>
</head>
<body>
    <!-- SIMPLE MODE -->
    <div class="container mode-simple" id="simpleMode">
        <h1>üìÑ Free PDF Merger (No Sign Up) | FreeMergePDF</h1>
        <div class="subtitle hero-inline">
            <span>Merge PDFs free in-browser‚Äîno signup, no uploads, no watermarks, 100% private.</span>
            <details class="hero-note">
                <summary>More about this tool</summary>
                <p>Merge PDFs in your browser. Free, private, no uploads, no watermarks.</p>
                <p>FreeMergePDF merges unlimited PDF files locally in your browser with no registration, no server uploads, and no watermarks on any device.</p>
            </details>
        </div>

        <div class="mode-simple">
            <div class="two-column">
                <div class="file-input-wrapper">
                    <label class="file-input-label">Select First PDF</label>
                    <div class="file-input-group" onclick="document.getElementById('file1').click()">
                        <input type="file" id="file1" accept=".pdf" />
                        <div class="file-input-display" id="display1">
                            <div class="file-input-icon">üìÅ</div>
                            <div class="file-input-text">Click or drag PDF here</div>
                            <div class="file-input-subtext">Any file size</div>
                        </div>
                    </div>
                </div>

                <div class="file-input-wrapper">
                    <label class="file-input-label">Select Second PDF</label>
                    <div class="file-input-group" onclick="document.getElementById('file2').click()">
                        <input type="file" id="file2" accept=".pdf" />
                        <div class="file-input-display" id="display2">
                            <div class="file-input-icon">üìÅ</div>
                            <div class="file-input-text">Click or drag PDF here</div>
                            <div class="file-input-subtext">Any file size</div>
                        </div>
                    </div>

                </div>
<!-- SIMPLE FILENAME INPUT -->
                <div class="filename-input-row">
                    <label for="simpleFilename">Download name:</label>
                    <input type="text" id="simpleFilename" />
                </div>
            </div>

            <div class="error-message" id="simpleError"></div>

            <!-- PROMINENT MERGE BUTTON -->
            <div class="simple-merge-section">
                
                <button class="merge-btn merge-btn-large" id="simpleMergeBtn" onclick="mergePDFs()" disabled>
                    ‚ö° Merge PDFs Now
                </button>

                

                <!-- ADVANCED OPTIONS -->
                <div class="simple-options-section">
                    <button class="simple-options-btn" id="simpleAdvancedBtn" onclick="openAdvancedSortFromSimple()" disabled>
                        ‚úèÔ∏è Advanced Merge + Compress (Sort Pages)
                    </button>
                    <button class="expand-btn merge-btn" id="expandBtn" onclick="toggleMode()">
                        ‚ûï Merge more than 2 files
                    </button>
                </div>

                <p class="simple-merge-hint">Use advanced merge to reorder pages</p>
            </div>

            <div class="memory-warning" id="simpleWarning"></div>

            <div class="status-area status-ready" id="simpleStatus">
                <span>Ready to merge</span>
            </div>
        </div>
    </div>

    <!-- EXPANDED MODE -->
    <div class="container mode-expanded" id="expandedMode">
        <div class="mode-toggle-header">
            <button class="back-to-simple" onclick="toggleMode()">‚Üê Back to 2 PDFs</button>
            <div class="mode-title">Merge Multiple PDFs</div>
            <div class="document-count" id="docCount">0 files</div>
        </div>

        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-text">üìÅ Drop PDFs here or click to add</div>
            <div class="drop-zone-subtext">You can select multiple files at once</div>
            <input type="file" id="expandedFileInput" accept=".pdf" multiple />
        </div>

        <div class="error-message" id="expandedError"></div>
        <div class="error-action" id="expandedErrorAction">
            <button class="error-action-btn" onclick="document.getElementById('expandedFileInput').click()">Reselect Files</button>
        </div>

        <div class="pdf-list" id="pdfList"></div>

        <div class="add-more-section">
            <button class="add-more-btn" onclick="document.getElementById('expandedFileInput').click()">
                ‚ûï Add more PDFs
            </button>
        </div>
        <!-- EXPANDED FILENAME INPUT -->
        <div class="filename-input-row">
            <label for="expandedFilename">Download name:</label>
            <input type="text" id="expandedFilename" />
        </div>

        <div class="button-group">
            <button class="merge-btn" id="advancedSortBtn" onclick="openAdvancedSort()" disabled>
                ‚úèÔ∏è Advanced Merge + Compress (Sort Pages)
            </button>
            <button class="merge-btn" id="expandedMergeBtn" onclick="mergePDFs()" disabled>
                Merge All PDFs
            </button>
        </div>


        <div class="memory-warning" id="expandedWarning"></div>
    </div>

    <!-- Feedback Form (appears after merge section on narrow screens) -->
    <div class="feedback-form-bottom" id="feedbackFormBottom">
        <div class="container">
            <h2 class="feedback-title">Help us improve</h2>
            
            <p class="feedback-message">
                <strong>Your feedback matters.</strong> We read every message and use it to make this tool better for you.
            </p>
            
            <div class="feedback-error" id="feedbackErrorBottom"></div>
            <div class="feedback-success" id="feedbackSuccessBottom">
                <div class="feedback-success-icon">‚úì</div>
                <p class="feedback-success-text">Thank you! I'll read your message and improve the tool based on your feedback.</p>
            </div>
            
            <form class="feedback-form" id="feedbackFormBottom">
                <input 
                    type="email" 
                    class="feedback-input" 
                    id="feedbackEmailBottom" 
                    placeholder="your@email.com" 
                    required
                />

                <input
                    type="text"
                    class="feedback-input"
                    id="feedbackUserNameBottom"
                    placeholder="Your name (optional)"
                />
                
                <div class="feedback-message-row">
                    <textarea 
                        class="feedback-textarea feedback-input" 
                        id="feedbackMessageBottom" 
                        placeholder="Tell me about bugs, feature ideas, or anything else..." 
                        required
                    ></textarea>

                    <button type="submit" class="feedback-button" id="feedbackSendBtnBottom">
                        Send Feedback
                    </button>
                </div>

                <label class="feedback-toggle">
                    <input type="checkbox" id="feedbackPrivateBottom" />
                    <span>Make this feedback private (won't be shown publicly)</span>
                </label>

                <div class="feedback-history" id="feedbackHistoryBottom">
                    <div class="feedback-history-heading">Recent feedback from users</div>
                    <ul class="feedback-history-list" id="feedbackHistoryListBottom"></ul>
                    <div class="feedback-history-empty" id="feedbackHistoryEmptyBottom">No feedback yet. Share your first note!</div>
                    <button type="button" class="feedback-show-toggle" id="feedbackShowToggleBottom">Show more feedback</button>
                </div>
            </form>
        </div>
    </div>

    <div class="seo-accordions">
        <!-- FEATURES SECTION -->
        <details class="seo-accordion" id="featuresAccordion">
            <summary>Features: free PDF merger, no signup, private</summary>
            <div class="seo-accordion-body">
                <div class="features">
                <h2>Why Choose FreeMergePDF - The Best Free PDF Merger No Sign Up Required?</h2>
                <ul class="feature-list">
                    <li><strong>No Signup or Registration Required</strong> - This free PDF merger, free PDF combiner, and free PDF joiner tool requires zero account creation. Start merging PDFs immediately without any registration hassle</li>
                    <li><strong>100% Private & Secure PDF Merging</strong> - Your files never leave your device. All PDF merging processing happens locally in your browser. This free online PDF merger keeps your documents completely private</li>
                    <li><strong>No File Upload to Servers</strong> - Files are processed entirely on your computer, ensuring complete privacy. The safest free PDF combiner available</li>
                    <li><strong>Completely Free PDF Tool</strong> - No hidden costs, no premium plans, no watermarks. This free PDF merger and PDF combiner is 100% free forever</li>
                    <li><strong>Unlimited PDF Documents</strong> - Merge as many PDFs as you want in one batch. No limits on the number of documents this free PDF joiner can combine</li>
                    <li><strong>Drag & Drop PDF Reordering</strong> - This free PDF combiner lets you reorder files before merging. Complete control over your merged PDF document</li>
                    <li><strong>Works Offline - Free PDF Merger</strong> - Once loaded, this free online PDF merger works without internet connection since all processing happens locally</li>
                    <li><strong>Cross-Platform PDF Merger</strong> - This free PDF merger works on Windows, Mac, Linux, iOS, and Android. Use this free PDF combiner on any device</li>
                </ul>
            </div>
        </div>
    </details>

    <!-- SEO CONTENT -->
    <details class="seo-accordion" id="seoCopyAccordion">
        <summary>About FreeMergePDF: free PDF combiner in your browser</summary>
        <div class="seo-accordion-body">
            <div class="seo-content">
        <h2>Free PDF Merger No Sign Up - FreeMergePDF: The Best Way to Merge PDF Files Online</h2>
        <p>FreeMergePDF is the best free PDF merger tool available. This free PDF combiner allows you to merge unlimited PDF files into a single document without any signup or registration. Our free PDF merger tool allows you to combine multiple PDF files in seconds using a completely free, no-signup PDF merger. Simply select your PDF files (start with 2, or expand to merge unlimited PDFs with our free PDF joiner), click merge, and download your combined PDF instantly. This free online PDF merger is perfect whether you call it a PDF merger, PDF combiner, or PDF joiner‚Äîit does it all without requiring an account.</p>
        
        <h3>Secure PDF Merging With No Signup - FreeMergePDF Free PDF Merger</h3>
        <p>Unlike other online PDF merger tools that upload your files to a server, FreeMergePDF (the free PDF combiner) processes everything locally in your browser. This means your sensitive documents never leave your computer, ensuring maximum privacy and security. This free PDF merger requires no signup because there's nothing to track. No data is stored, collected, or transmitted to any server. Whether you're using this free PDF joiner for business contracts, personal documents, or anything else, your privacy is guaranteed with FreeMergePDF's free PDF merger.</p>
        
        <h3>Free PDF Combiner With No Hidden Costs - FreeMergePDF</h3>
        <p>Merge PDF files without any cost using FreeMergePDF. No subscription required, no trial periods, and no watermarks on your merged documents from this free PDF merger and PDF combiner. This free online PDF joiner is completely free to use with unlimited merges and no limits on the number of documents. FreeMergePDF is the best free PDF merger because it costs nothing and requires no signup whatsoever.</p>
        
        <h3>How FreeMergePDF Free PDF Merger Works</h3>
        <p>This free PDF combiner uses client-side JavaScript processing to merge your PDF files directly in your web browser. With FreeMergePDF, you select your PDF files, arrange them in the order you want, and click the merge button on this free PDF merger. The merged PDF will automatically download to your device in seconds. This free PDF joiner requires no technical knowledge and works instantly. Whether you need a free PDF merger, free PDF combiner, or free PDF joiner, FreeMergePDF delivers all functionality without signup.</p>
        
        <h3>Merge Multiple PDFs With Drag-and-Drop Reordering - Free PDF Merger</h3>
        <p>Need to merge more than 2 PDFs? FreeMergePDF (the best free PDF combiner and free PDF joiner) offers an advanced mode where you can merge unlimited documents. Simply select "merge more than 2 files" to expand into our free PDF merger's advanced mode. Drag and drop your PDFs to arrange them in any order before merging. This free PDF combiner is perfect for combining presentations, reports, contracts, or any multi-document projects. FreeMergePDF's free PDF joiner gives you complete control over your merged documents‚Äîno signup required, completely free.</p>

        <h3>More guides on free PDF merging</h3>
        <ul>
            <li><a href="/blog-post-1.html">Free PDF merger no sign up ‚Äì full guide</a></li>
            <li><a href="/blog-post-2.html">Merge PDF files online free ‚Äì step-by-step</a></li>
            <li><a href="/blog-post-3.html">How to merge PDF without software</a></li>
            <li><a href="/blog.html">Browse all FreeMergePDF tutorials</a></li>
        </ul>
    </div>
        </div>
    </details>

    <!-- FAQ SECTION -->
    <details class="seo-accordion" id="faqAccordion">
        <summary>FAQ: free, private PDF combiner answers</summary>
        <div class="seo-accordion-body">
    <div class="seo-content">
        <h2>Frequently Asked Questions About Free PDF Mergers</h2>
        
        <h3>Is FreeMergePDF really a free PDF merger with no sign up required?</h3>
        <p>Yes! FreeMergePDF is completely free to use with absolutely no signup, registration, or account creation required. Our free PDF merger requires zero hidden fees, subscriptions, or premium plans. There are no watermarks on your merged documents, and you can merge unlimited PDFs at no cost.</p>
        
        <h3>What's the difference between FreeMergePDF and other PDF mergers?</h3>
        <p>FreeMergePDF (also known as the free PDF merger tool or free PDF combiner) is unique because it processes everything locally in your browser. Unlike other online PDF tools that upload your files to servers, our free PDF merger keeps your files completely private. No signup needed, no data collected, and no company access to your documents. Whether you call it a PDF merger, PDF combiner, or PDF joiner, FreeMergePDF delivers all the functionality without the account requirements.</p>
        
        <h3>Are there any file size limits on this free PDF merger?</h3>
        <p>No file size limits! Our free PDF merger can handle PDFs of any size. Since all processing happens locally in your browser on your device, the only limitation is your device's available memory. This free online PDF merger is perfect for combining large documents without restrictions.</p>
        
        <h3>Can I use this free PDF combiner to merge more than 2 PDFs at once?</h3>
        <p>Absolutely! By default, FreeMergePDF shows a simple 2-PDF merger for quick combining. But this free PDF combiner also offers an expanded advanced mode where you can merge unlimited PDFs in one batch with drag-and-drop reordering. Whether you're using the free PDF joiner for 2 files or 20, it handles it all without signup or restrictions.</p>
        
        <h3>How does FreeMergePDF ensure my privacy with no signup requirement?</h3>
        <p>Unlike other online PDF tools that upload your files to their servers, our free PDF merger processes everything directly in your web browser using JavaScript. Your PDF files never leave your device, are never uploaded to any server, and are never stored anywhere. No signup means no account to hack, no email to spam, and no data to collect. Once you close the browser tab, all data is immediately cleared. This makes FreeMergePDF one of the most private free PDF mergers available‚Äîno signup, no data collection, completely secure.</p>
        
        <h3>Do I need to create an account or sign up for this free PDF merger?</h3>
        <p>No‚Äîabsolutely not! FreeMergePDF requires zero signup. No registration, no account creation, no email address needed. Just visit FreeMergePDF, select your PDFs, and start merging instantly. This free PDF merger works without signup because we don't need to track you. All processing happens on your device, not on our servers.</p>
        
        <h3>What devices and browsers does the free PDF merger FreeMergePDF support?</h3>
        <p>This free PDF merger works on any device with a modern web browser, including Windows, Mac, Linux, iOS (iPhone/iPad), and Android. FreeMergePDF supports Chrome, Firefox, Safari, Edge, and other modern browsers. No software installation is required‚Äîjust open your browser and use the free PDF merger instantly.</p>
        
        <h3>Can I use FreeMergePDF offline‚Äîthe free PDF merger?</h3>
        <p>Once the page is loaded, FreeMergePDF (your free PDF merger) can work without an internet connection since all processing happens locally on your device. However, you'll need internet to initially load the page and the PDF processing library for the first time.</p>
        
        <h3>How fast is this free online PDF merger?</h3>
        <p>FreeMergePDF merges PDFs nearly instantly‚Äîusually just a few seconds regardless of file size. Since this free PDF merger doesn't upload to servers or require signup confirmation, the speed depends only on your device's processing power.</p>
        
        <h3>Is FreeMergePDF safe for confidential or sensitive PDFs?</h3>
        <p>Absolutely. FreeMergePDF is extremely safe because your files are processed entirely within your browser using client-side JavaScript. No data is transmitted over the internet, stored on any server, or accessible to anyone else. Unlike cloud-based PDF mergers that require signup and upload your files, FreeMergePDF keeps everything private. This free PDF merger is ideal for merging confidential documents, contracts, medical records, and sensitive files.</p>

        <h3>Can I reorder PDFs before merging with the free PDF merger?</h3>
        <p>Yes! In expanded mode, simply click "Advanced Merge + Compress (Sort Pages)" to sort individual pages from all your PDFs. You can drag and drop pages to arrange them in any order. The numbered cards will update automatically to show the merge order. FreeMergePDF's free PDF combiner gives you complete control before you merge.</p>
    </div>
        </div>
        </details>
    </div>

    <!-- FAQ Schema for Google Rich Results -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Is FreeMergePDF really a free PDF merger with no signup required?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! FreeMergePDF is completely free to use with absolutely no signup, registration, or account creation required. Our free PDF merger requires zero hidden fees, subscriptions, or premium plans."
          }
        },
        {
          "@type": "Question",
          "name": "Are there any file size limits on this free PDF merger?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No file size limits! Our free PDF merger can handle PDFs of any size. Since all processing happens locally in your browser on your device, the only limitation is your device's available memory."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use this free PDF combiner to merge more than 2 PDFs at once?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Absolutely! By default, FreeMergePDF shows a simple 2-PDF merger for quick combining. But this free PDF combiner also offers an expanded advanced mode where you can merge unlimited PDFs in one batch."
          }
        },
        {
          "@type": "Question",
          "name": "How does FreeMergePDF ensure my privacy with no signup requirement?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Unlike other online PDF tools that upload your files to their servers, our free PDF merger processes everything directly in your web browser using JavaScript. Your PDF files never leave your device."
          }
        },
        {
          "@type": "Question",
          "name": "Do I need to create an account or sign up for this free PDF merger?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No‚Äîabsolutely not! FreeMergePDF requires zero signup. No registration, no account creation, no email address needed. Just visit FreeMergePDF, select your PDFs, and start merging instantly."
          }
        }
      ]
    }
    </script>

    <!-- FOOTER WITH BLOG LINK -->
    <div class="footer-links">
        <a href="/blog.html">Blog</a>
        <span class="footer-separator">|</span>
        <a href="/privacy.html">Privacy Policy</a>
        <span class="footer-separator">|</span>
        <a href="/terms.html">Terms of Service</a>
        <span class="footer-separator">|</span>
        <a href="/contact.html">Contact Us</a>
    </div>

    <!-- ADVANCED MERGE MODAL -->
    <div id="advancedMergeModal" class="advanced-merge-modal">
        <div class="advanced-merge-container">
            <div class="advanced-merge-header">
                <h2>Sort PDF Pages</h2>
                <span class="advanced-merge-header-info">Drag to reorder pages from different files</span>
                <button class="advanced-merge-close-btn" onclick="closeAdvancedSort()">‚úï</button>
            </div>
            
            <div class="advanced-merge-content">
                <div id="advancedMergeContent"></div>
            </div>
            
            <div class="advanced-merge-footer">
                <div class="advanced-merge-page-count">
                    <strong id="pageCount">0</strong> pages total
                </div>
                <div class="memory-warning" id="advancedMergeWarning"></div>
                <div class="advanced-merge-filename-input">
                    <label for="customFilename">Filename:</label>
                    <input type="text" id="customFilename" placeholder="merged.pdf" />
                </div>
                <div class="advanced-merge-compression">
                    <div class="advanced-merge-compression-toggle">
                        <input type="checkbox" id="advancedCompressionToggle">
                        <label for="advancedCompressionToggle" class="advanced-merge-compression-toggle-btn">Compression Off</label>
                    </div>
                    <div class="advanced-merge-compression-options" id="advancedCompressionOptions" role="radiogroup" aria-label="Compression mode">
                        <div class="advanced-merge-compression-option">
                            <input type="radio" name="advancedCompressionMode" id="advancedCompressionStandard" value="standard" checked>
                            <label for="advancedCompressionStandard">
                                <span class="advanced-merge-compression-name">Standard</span>
                                <span class="advanced-merge-compression-desc">Keep text + images. Light structural compression.</span>
                                <span class="advanced-merge-compression-badge">Fast</span>
                            </label>
                        </div>
                        <div class="advanced-merge-compression-option">
                            <input type="radio" name="advancedCompressionMode" id="advancedCompressionImages" value="images">
                            <label for="advancedCompressionImages">
                                <span class="advanced-merge-compression-name">Image-heavy pages</span>
                                <span class="advanced-merge-compression-desc">Recompress scanned/image pages. Text stays text.</span>
                                <span class="advanced-merge-compression-badge advanced-merge-compression-badge-strong">Smaller</span>
                            </label>
                        </div>
                    </div>
                    <div class="advanced-merge-compression-settings" id="advancedRasterSettings">
                        <label for="advancedRasterQuality">
                            JPEG quality
                            <span class="advanced-merge-compress-value" id="advancedRasterQualityValue">60%</span>
                        </label>
                        <input type="range" id="advancedRasterQuality" min="0.4" max="0.9" step="0.05" value="0.6">
                        <label for="advancedRasterScale">
                            Resolution
                            <span class="advanced-merge-compress-value" id="advancedRasterScaleValue">100%</span>
                        </label>
                        <input type="range" id="advancedRasterScale" min="0.5" max="1.0" step="0.05" value="1.0">
                    </div>
                </div>
                <div class="advanced-merge-actions">
                    <button class="advanced-merge-btn advanced-merge-btn-reset" onclick="resetPageOrder()">
                        ‚Üª Reset Order
                    </button>
                    <button class="advanced-merge-btn advanced-merge-btn-secondary" onclick="closeAdvancedSort()">
                        Cancel
                    </button>
                    <button class="advanced-merge-btn advanced-merge-btn-primary" onclick="finalizeAdvancedMerge()">
                        ‚úì Apply & Merge
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="error-reporting.js?v=2"></script>
    <script src="advanced-pdf-merger.js?v=6"></script>

    <script>
        const MEMORY_WARNING_THRESHOLD = 300 * 1024 * 1024; // 300MB total
        const MERGE_HARD_LIMIT_BYTES = 1500 * 1024 * 1024; // 1.5GB hard cap to avoid memory errors
        let expandedFiles = []; // Store file objects for expanded mode
        let advancedMerger = null; // Advanced merger instance
        let advancedMergerPrewarmKey = '';
        let advancedMergerPrewarmPromise = null;
        let advancedPageCountListenerAttached = false;
        let mergeInProgress = false;
        const encryptedWarningShown = { simple: false, expanded: false };
        const encryptionScanResults = new WeakMap();
        const fileIssues = new WeakMap();
        let advancedMergerFiles = [];
        let advancedFileErrorShown = false;
        const ENCRYPTION_SCAN_BYTES = 65536;

        // ===== MODE TOGGLE =====
        function toggleMode() {
            const simpleMode = document.getElementById('simpleMode');
            const expandedMode = document.getElementById('expandedMode');

            simpleMode.classList.toggle('hidden');
            expandedMode.classList.toggle('active');

            if (expandedMode.classList.contains('active')) {
                // Clear expanded mode files when switching
                expandedFiles = [];
                encryptedWarningShown.expanded = false;
                document.getElementById('pdfList').innerHTML = '';
                updateDocCount();
                updateExpandedMergeButton();
                advancedMergerPrewarmKey = '';
                if (advancedMerger) {
                    advancedMerger.destroy();
                    advancedMerger = null;
                }
                // Page count display reset
                const pageCountEl = document.getElementById('pageCount');
                if (pageCountEl) pageCountEl.textContent = '0';
            }
        }

        // ===== SIMPLE MODE - FILE HANDLING =====
        function setupSimpleFileInputs() {
            const file1Input = document.getElementById('file1');
            const file2Input = document.getElementById('file2');
            const display1 = document.getElementById('display1');
            const display2 = document.getElementById('display2');

            [file1Input, file2Input].forEach((input, index) => {
                const display = index === 0 ? display1 : display2;
                const displayId = index === 0 ? 'display1' : 'display2';

                input.addEventListener('change', async (e) => {
                    await handleSimpleFileSelect(e.target.files[0], displayId, input.id);
                });

                display.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    display.style.borderColor = '#764ba2';
                    display.style.background = '#e0e7ff';
                });

                display.addEventListener('dragleave', () => {
                    display.style.borderColor = '#667eea';
                    display.style.background = '#f8f9fa';
                });

                display.addEventListener('drop', (e) => {
                    e.preventDefault();
                    display.style.borderColor = '#667eea';
                    display.style.background = '#f8f9fa';
                    if (e.dataTransfer.files.length > 0) {
                        const dt = new DataTransfer();
                        dt.items.add(e.dataTransfer.files[0]);
                        input.files = dt.files;
                        input.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            });
        }

        async function handleSimpleFileSelect(file, displayId, inputId) {
            if (!file) return;
            clearError('simpleError');

            if (file.type !== 'application/pdf') {
                showError('Please select a PDF file.', 'simpleError');
                document.getElementById(inputId).value = '';
                return;
            }

            if (file.size === 0) {
                showError('Please select a non-empty PDF file.', 'simpleError');
                document.getElementById(inputId).value = '';
                return;
            }

            if (!(await hasPdfHeader(file))) {
                showError('Please select a valid PDF file (missing header).', 'simpleError');
                document.getElementById(inputId).value = '';
                return;
            }

            queueEncryptionScan(file, 'simpleError', 'simple', inputId);

            const display = document.getElementById(displayId);
            display.innerHTML = `
                <div class="file-name">‚úì ${file.name}</div>
                <div class="file-size">${formatFileSize(file.size)}</div>
                <button class="file-clear-btn" onclick="clearSimpleFile('${inputId}', '${displayId}')">Clear</button>
            `;
            display.classList.add('has-file');

            updateSimpleMergeButton();
        }

        function clearSimpleFile(inputId, displayId) {
            document.getElementById(inputId).value = '';
            const display = document.getElementById(displayId);
            display.innerHTML = `
                <div class="file-input-icon">üìÅ</div>
                <div class="file-input-text">Click or drag PDF here</div>
                <div class="file-input-subtext">Any file size</div>
            `;
            display.classList.remove('has-file');
            encryptedWarningShown.simple = false;
            updateSimpleMergeButton();
        }

        function updateSimpleMergeButton() {
            const file1 = document.getElementById('file1').files[0];
            const file2 = document.getElementById('file2').files[0];
            const btn = document.getElementById('simpleMergeBtn');
            const advBtn = document.getElementById('simpleAdvancedBtn');
            
            const files = [file1, file2].filter(Boolean);
            const hasFiles = files.length === 2;
            btn.disabled = !hasFiles;
            advBtn.disabled = !hasFiles;

            const input = document.getElementById('simpleFilename');
            if (hasFiles) {
                let filename;
                if (input) {
                    if (!input.dataset.userEdited) {
                        input.value = generateDefaultFilename(files);
                    }
                    filename = getFinalFilename(input.value, files);
                } else {
                    filename = generateDefaultFilename(files);
                }
                updateSimpleMergeButtonLabel(filename);
            } else {
                if (btn) {
                    btn.textContent = '‚ö° Merge PDFs Now';
                }
                if (input && !input.dataset.userEdited) {
                    input.value = '';
                }
            }

            checkMemoryWarning(files, 'simpleWarning');
            // Prime advanced merge thumbnails in the background when both simple files are ready
            if (hasFiles) {
                primeAdvancedMergeIfReady(files);
            }
            attachPageCountListener();
        }

        // ===== EXPANDED MODE - FILE HANDLING =====
        function setupExpandedFileInputs() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('expandedFileInput');

            fileInput.addEventListener('change', async (e) => {
                await handleExpandedFileSelect(e.target.files);
                e.target.value = '';
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                await handleExpandedFileSelect(e.dataTransfer.files);
            });

            dropZone.addEventListener('click', () => {
                fileInput.click();
            });
        }

        async function handleExpandedFileSelect(files) {
            if (files && files.length) {
                clearError('expandedError');
                advancedFileErrorShown = false;
            }

            for (let file of files) {
                let issueReason = '';
                if (file.type !== 'application/pdf') {
                    issueReason = 'Not a PDF file';
                } else if (file.size === 0) {
                    issueReason = 'Empty PDF (0 bytes)';
                } else if (!(await hasPdfHeader(file))) {
                    issueReason = 'Missing PDF header';
                }
                if (issueReason) {
                    markFileIssue(file, issueReason);
                    showError(`File added but will be skipped: ${issueReason}.`, 'expandedError');
                } else {
                    clearFileIssue(file);
                }

                expandedFiles.push(file);
                if (!issueReason) {
                    queueEncryptionScan(file, 'expandedError', 'expanded');
                }
            }

            renderPdfList();
            updateDocCount();
            updateExpandedMergeButton();
            primeAdvancedMergeIfReady(expandedFiles);
            attachPageCountListener();
        }

        function renderPdfList() {
            // Remove any gaps/undefined entries to avoid runtime errors
            expandedFiles = expandedFiles.filter((f) => f);
            const list = document.getElementById('pdfList');
            list.innerHTML = '';

            expandedFiles.forEach((file, index) => {
                if (!file || typeof file.name !== 'string') return;
                const issue = getFileIssue(file);
                const card = document.createElement('div');
                card.className = issue ? 'pdf-card pdf-card-invalid' : 'pdf-card';
                card.draggable = true;
                card.dataset.index = index;

                card.innerHTML = `
                    <div class="drag-handle">‚ãÆ‚ãÆ</div>
                    <div class="pdf-order">${index + 1}</div>
                    <div class="pdf-info">
                        <div class="pdf-name">${file.name}</div>
                        <div class="pdf-size">${formatFileSize(file.size)}</div>
                        ${issue ? `<div class="pdf-issue">Not mergeable: ${issue.reason}</div>` : ''}
                    </div>
                    <button class="pdf-delete" onclick="removeExpandedFile(${index})">‚úï</button>
                `;

                card.addEventListener('dragstart', (e) => {
                    card.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('index', index);
                });

                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                });

                card.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const draggedIndex = parseInt(e.dataTransfer.getData('index'));
                    if (draggedIndex !== index) {
                        [expandedFiles[draggedIndex], expandedFiles[index]] = [expandedFiles[index], expandedFiles[draggedIndex]];
                        renderPdfList();
                    }
                });

                list.appendChild(card);
            });
        }

        function removeExpandedFile(index) {
            const removed = expandedFiles.splice(index, 1)[0];
            clearFileIssue(removed);
            if (expandedFiles.length === 0) {
                advancedFileErrorShown = false;
            }
            renderPdfList();
            updateDocCount();
            updateExpandedMergeButton();
            primeAdvancedMergeIfReady(expandedFiles);
            attachPageCountListener();
        }

        function updateDocCount() {
            const total = expandedFiles.length;
            const skipped = getUnmergeableCount(expandedFiles);
            let label = total === 0 ? '0 files' : `${total} file${total !== 1 ? 's' : ''}`;
            if (skipped > 0) {
                label += ` (${skipped} skipped)`;
            }
            document.getElementById('docCount').textContent = label;
        }

        function updateExpandedMergeButton() {
            const advBtn = document.getElementById('advancedSortBtn');
            const mergeBtn = document.getElementById('expandedMergeBtn');

            const mergeableFiles = getMergeableFiles(expandedFiles);
            const hasFiles = mergeableFiles.length >= 2;
            if (advBtn) advBtn.disabled = !hasFiles;
            if (mergeBtn) mergeBtn.disabled = !hasFiles;
            
            const input = document.getElementById('expandedFilename');
            if (hasFiles) {
                let filename;
                if (input) {
                    if (!input.dataset.userEdited) {
                        input.value = generateDefaultFilename(mergeableFiles);
                    }
                    filename = getFinalFilename(input.value, mergeableFiles);
                } else {
                    filename = generateDefaultFilename(mergeableFiles);
                }
                updateExpandedMergeButtonLabel(filename);
            } else {
                if (mergeBtn) {
                    mergeBtn.textContent = 'Merge All PDFs';
                }
                if (input && !input.dataset.userEdited) {
                    input.value = '';
                }
            }

            checkMemoryWarning(mergeableFiles, 'expandedWarning');
        }

        // ===== UTILITY FUNCTIONS =====
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        function markFileIssue(file, reason) {
            if (!file) return;
            fileIssues.set(file, { reason, canMerge: false });
        }

        function clearFileIssue(file) {
            if (!file) return;
            fileIssues.delete(file);
        }

        function getFileIssue(file) {
            return fileIssues.get(file) || null;
        }

        function isMergeableFile(file) {
            const issue = getFileIssue(file);
            return !issue || issue.canMerge !== false;
        }

        function getMergeableFiles(files = []) {
            return Array.from(files || []).filter((file) => file && typeof file.name === 'string' && isMergeableFile(file));
        }

        function getUnmergeableCount(files = []) {
            return Array.from(files || []).filter((file) => file && typeof file.name === 'string' && !isMergeableFile(file)).length;
        }

        function describeFileIssue(info) {
            const err = info?.error;
            if (isEncryptedPdfError(err)) return 'Locked PDF';
            if (isCorruptPdfError(err)) return 'Corrupted or invalid PDF';
            if (isMemoryError(err)) return 'Too large to preview here';
            if (isFileReadError(err)) return 'File unavailable (moved or permission)';
            const msg = `${err?.message || info?.reason || ''}`.trim();
            if (!msg) return 'Could not be processed';
            if (msg.toLowerCase().includes('file index')) return 'Could not be processed';
            return msg.replace(/^Error:\s*/i, '');
        }

        function handleAdvancedFileError(info) {
            const fileIndex = info?.fileIndex;
            let file = null;
            const err = info?.error;
            if (Array.isArray(advancedMergerFiles) && Number.isInteger(fileIndex)) {
                file = advancedMergerFiles[fileIndex] || null;
                if (file) {
                    markFileIssue(file, describeFileIssue(info));
                    advancedMergerFiles[fileIndex] = null;
                }
            }
            if (!file && Array.isArray(expandedFiles) && Number.isInteger(fileIndex)) {
                file = expandedFiles[fileIndex] || null;
                if (file) {
                    markFileIssue(file, describeFileIssue(info));
                }
            }

            renderPdfList();
            updateDocCount();
            updateExpandedMergeButton();
            checkMemoryWarning(getMergeableFiles(expandedFiles), 'advancedMergeWarning');
            if (!advancedFileErrorShown) {
                advancedFileErrorShown = true;
                let msg = 'Some files were skipped.';
                if (isEncryptedPdfError(err)) {
                    msg = 'Locked PDF. Unlock to include it.';
                } else if (isCorruptPdfError(err)) {
                    msg = 'Not a valid PDF. Try another file.';
                } else if (isMemoryError(err)) {
                    msg = 'Too large to preview. Use fewer files/pages.';
                } else if (isFileReadError(err)) {
                    msg = "Can't read a file. Re-select it.";
                }
                showError(msg, 'expandedError');
            }
        }

        function handleAdvancedAllFilesFailed() {
            renderPdfList();
            updateDocCount();
            updateExpandedMergeButton();
            showError('All selected files became unavailable. Please reselect them (copy locally if needed).', 'expandedError');
        }

        function clearError(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;
            element.textContent = '';
            element.classList.remove('show');
            const actionId = elementId === 'expandedError' ? 'expandedErrorAction' : null;
            if (actionId) {
                const action = document.getElementById(actionId);
                if (action) action.classList.remove('show');
            }
        }

        function showError(message, elementId) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.classList.add('show');
            flashUploadGlow(elementId);
            const actionId = elementId === 'expandedError' ? 'expandedErrorAction' : null;
            if (actionId) {
                const action = document.getElementById(actionId);
                if (action) action.classList.add('show');
            }
        }

        function getAffiliateInlineHtml() {
            return ' <span class="affiliate-inline">Need signatures or forms? ' +
                '<a href="https://www.jotform.com/ai/agents/?partner=freemergepdf" ' +
                'target="_blank" rel="nofollow sponsored">Try Jotform AI ‚Üí</a></span>';
        }

        function promptSkipFile(file, error) {
            const name = file && file.name ? `"${file.name}"` : 'this file';
            const reason = error && error.message ? error.message : 'Unknown error';
            return window.confirm(
                `${name} could not be processed.\n` +
                `Reason: ${reason}\n\n` +
                'Click OK to skip this file and continue merging.\n' +
                'Click Cancel to stop the merge.'
            );
        }

        function flashUploadGlow(elementId) {
            let targets = [];
            if (elementId === 'simpleError') {
                targets = [document.getElementById('display1'), document.getElementById('display2')];
            } else if (elementId === 'expandedError') {
                targets = [document.getElementById('dropZone')];
            }

            targets.forEach((target) => {
                if (!target) return;
                target.classList.remove('upload-error-glow');
                void target.offsetWidth;
                target.classList.add('upload-error-glow');
                setTimeout(() => target.classList.remove('upload-error-glow'), 900);
            });
        }

        function checkMemoryWarning(files, elementId) {
            const totalSize = files.reduce((sum, f) => sum + (f ? f.size : 0), 0);
            const warning = document.getElementById(elementId);

            if (totalSize > MEMORY_WARNING_THRESHOLD) {
                warning.textContent = '‚ö†Ô∏è Large file size detected. Merge may fail due to memory. Try fewer or smaller PDFs.';
                warning.classList.add('show');
            } else {
                warning.classList.remove('show');
            }
        }

        // ===== ADVANCED MERGE PREWARM HELPERS =====
        const __scriptLoadPromises = new Map();

        function loadScriptOnce(src, id) {
            if (!src) return Promise.reject(new Error('Missing script src'));
            const key = id || src;
            if (__scriptLoadPromises.has(key)) return __scriptLoadPromises.get(key);

            const existing = id ? document.getElementById(id) : document.querySelector(`script[src="${src}"]`);
            if (existing) {
                const resolved = Promise.resolve(true);
                __scriptLoadPromises.set(key, resolved);
                return resolved;
            }

            const promise = new Promise((resolve, reject) => {
                const script = document.createElement('script');
                if (id) script.id = id;
                script.src = src;
                script.async = true;
                script.onload = () => resolve(true);
                script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                document.head.appendChild(script);
            });
            __scriptLoadPromises.set(key, promise);
            return promise;
        }

        async function ensurePdfJsReady() {
            if (typeof pdfjsLib !== 'undefined' && pdfjsLib.getDocument) return true;
            try {
                await loadScriptOnce('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js', 'pdfjs-cdn-fallback');
            } catch (err) {
                return false;
            }
            return typeof pdfjsLib !== 'undefined' && pdfjsLib.getDocument;
        }

        async function ensurePdfLibReady() {
            if (typeof PDFLib !== 'undefined' && PDFLib.PDFDocument) return true;
            try {
                await loadScriptOnce('https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js', 'pdflib-cdn-fallback');
            } catch (err) {
                return false;
            }
            return typeof PDFLib !== 'undefined' && PDFLib.PDFDocument;
        }

        async function ensurePdfLibReadyWithRetry() {
            const ok = await ensurePdfLibReady();
            if (ok) return true;
            await new Promise(resolve => setTimeout(resolve, 300));
            return ensurePdfLibReady();
        }

        async function ensureAdvancedMergerReady() {
            if (typeof AdvancedPDFMerger !== 'undefined') return true;
            try {
                await loadScriptOnce('advanced-pdf-merger.js?v=6', 'advanced-merger-fallback');
            } catch (err) {
                return false;
            }
            return typeof AdvancedPDFMerger !== 'undefined';
        }

        async function ensureAdvancedDependencies() {
            if (window.__advancedDepsReady) return true;
            const pdfOk = await ensurePdfJsReady();
            const mergerOk = await ensureAdvancedMergerReady();
            window.__advancedDepsReady = pdfOk && mergerOk;
            return window.__advancedDepsReady;
        }

        function buildFilesKey(files) {
            return files.map(f => `${f.name}-${f.size}-${f.lastModified || 0}`).join('|');
        }

        function attachPageCountListener() {
            if (advancedPageCountListenerAttached) return;
            const container = document.getElementById('advancedMergeContent');
            if (!container) return;

            container.addEventListener('pagecountchange', (e) => {
                const count = e.detail?.count ?? 0;
                const pageCountEl = document.getElementById('pageCount');
                if (pageCountEl) pageCountEl.textContent = count;
            });

            advancedPageCountListenerAttached = true;
        }

        async function getAdvancedMergerInstance() {
            const depsOk = await ensureAdvancedDependencies();
            if (!depsOk) return null;
            if (!advancedMerger) {
                advancedMerger = new AdvancedPDFMerger({
                    maxPagesInMemory: 100,
                    thumbnailScale: 1.2,
                    jpegQuality: 0.7,
                    maxPreRenderPages: 120,
                    onFileError: handleAdvancedFileError,
                    onAllFilesFailed: handleAdvancedAllFilesFailed
                });
            }
            return advancedMerger;
        }

        async function ensureAdvancedPrepared(files) {
            const mergeableFiles = getMergeableFiles(files);
            if (!mergeableFiles || mergeableFiles.length < 2) return null;

            const key = buildFilesKey(mergeableFiles);
            if (advancedMergerPrewarmPromise) {
                await advancedMergerPrewarmPromise;
            }

            if (advancedMerger && advancedMergerPrewarmKey === key && advancedMerger.pages && advancedMerger.pages.length) {
                advancedMergerFiles = mergeableFiles.slice();
                return advancedMerger;
            }

            // New set of files: reset and warm thumbnails in the background
            if (advancedMerger) {
                advancedMerger.destroy();
                advancedMerger = null;
            }

            const merger = await getAdvancedMergerInstance();
            if (!merger) {
                showError('Advanced merge failed to load. Please refresh the page.', 'expandedError');
                return null;
            }
            advancedMergerPrewarmKey = key;

            const container = document.getElementById('advancedMergeContent');
            if (!container) return null;

            container.innerHTML = '';
            advancedMergerFiles = mergeableFiles.slice();
            advancedMergerPrewarmPromise = merger.initialize(mergeableFiles, '#advancedMergeContent')
                .catch((err) => {
                    console.error('Advanced merge prewarm failed:', err);
                    advancedMergerPrewarmKey = '';
                    advancedMergerFiles = [];
                })
                .finally(() => {
                    advancedMergerPrewarmPromise = null;
                });

            await advancedMergerPrewarmPromise;
            return merger;
        }

        function primeAdvancedMergeIfReady(files) {
            const mergeableFiles = getMergeableFiles(files);
            advancedMergerFiles = mergeableFiles.slice();
            if (mergeableFiles && mergeableFiles.length >= 2) {
                ensureAdvancedPrepared(mergeableFiles);
            }
        }

        /**
         * Generate default filename from uploaded files
         * Ensures filename doesn't exceed OS limits (255 chars)
         */
        function generateDefaultFilename(files) {
            if (files.length === 0) return 'merged.pdf';
            
            // Get names without extension, max 15 chars each
            const names = files.map(f => {
                return f.name.replace(/\.pdf$/i, '').substring(0, 15);
            });

            let filename;
            if (files.length === 1) {
                filename = `${names[0]}_merged.pdf`;
            } else if (files.length === 2) {
                filename = `${names[0]}_${names[1]}_merged.pdf`;
            } else {
                // 3+ files: file1_file2_more_files_merged.pdf
                filename = `${names[0]}_${names[1]}_more_files_merged.pdf`;
            }

            // Safety check: if filename exceeds 200 chars, truncate
            if (filename.length > 200) {
                // Keep first file name + more_files_merged.pdf
                const safeLength = 200 - "_more_files_merged.pdf".length;
                filename = names[0].substring(0, safeLength) + "_more_files_merged.pdf";
            }

            return filename;
        }

        // ===== FILENAME HELPERS (NEW) =====
        function getFinalFilename(rawName, files) {
            const trimmed = (rawName || '').trim();
            let filename = trimmed || generateDefaultFilename(files);
            if (!/\.pdf$/i.test(filename)) {
                filename += '.pdf';
            }
            return filename;
        }

        function updateSimpleMergeButtonLabel(filename) {
            const btn = document.getElementById('simpleMergeBtn');
            if (!btn) return;
            btn.textContent = `‚ö° Merge & Download ${filename}`;
        }

        function updateExpandedMergeButtonLabel(filename) {
            const btn = document.getElementById('expandedMergeBtn');
            if (!btn) return;
            btn.textContent = `Merge & Download ${filename}`;
        }

        function setupFilenameInputs() {
            const simpleInput = document.getElementById('simpleFilename');
            if (simpleInput) {
                simpleInput.addEventListener('input', () => {
                    simpleInput.dataset.userEdited = 'true';
                    const file1 = document.getElementById('file1').files[0];
                    const file2 = document.getElementById('file2').files[0];
                    const files = [file1, file2].filter(Boolean);
                    if (!files.length) return;
                    const filename = getFinalFilename(simpleInput.value, files);
                    updateSimpleMergeButtonLabel(filename);
                });
            }

            const expandedInput = document.getElementById('expandedFilename');
            if (expandedInput) {
                expandedInput.addEventListener('input', () => {
                    expandedInput.dataset.userEdited = 'true';
                    const files = getMergeableFiles(expandedFiles || []);
                    if (!files.length) return;
                    const filename = getFinalFilename(expandedInput.value, files);
                    updateExpandedMergeButtonLabel(filename);
                });
            }
        }

        // ===== ADVANCED MERGE FUNCTIONS =====
        async function openAdvancedSortFromSimple() {
            const file1 = document.getElementById('file1').files[0];
            const file2 = document.getElementById('file2').files[0];

            if (!file1 || !file2) {
                showError('Please select 2 PDF files first.', 'simpleError');
                return;
            }

            const mergeableFiles = getMergeableFiles([file1, file2]);
            if (mergeableFiles.length < 2) {
                showError('Select at least 2 mergeable PDFs before using Advanced Merge.', 'simpleError');
                return;
            }

            // Set expandedFiles for advanced merger
            expandedFiles = [file1, file2];
            encryptedWarningShown.expanded = false;
            queueEncryptionScan(file1, 'expandedError', 'expanded');
            queueEncryptionScan(file2, 'expandedError', 'expanded');

            // Set default filename
            const defaultName = generateDefaultFilename(mergeableFiles);
            document.getElementById('customFilename').value = defaultName;

            await ensureAdvancedPrepared(mergeableFiles);
            checkMemoryWarning(mergeableFiles, 'advancedMergeWarning');

            // Open modal once prewarmed (or immediately if already ready)
            document.getElementById('advancedMergeModal').classList.add('active');
            document.getElementById('pageCount').textContent = advancedMerger?.pages?.length || 0;
        }

        async function openAdvancedSort() {
            const isExpanded = document.getElementById('expandedMode').classList.contains('active');
            
            if (!isExpanded) {
                showError('Please switch to expanded mode first (merge multiple files).', 'expandedError');
                return;
            }

            if (expandedFiles.length < 2) {
                showError('Please add at least 2 files to use advanced sorting.', 'expandedError');
                return;
            }

            // Set default filename
            const mergeableFiles = getMergeableFiles(expandedFiles);
            if (mergeableFiles.length < 2) {
                showError('Please select at least 2 mergeable PDF files.', 'expandedError');
                return;
            }

            const defaultName = generateDefaultFilename(mergeableFiles);
            document.getElementById('customFilename').value = defaultName;

            await ensureAdvancedPrepared(mergeableFiles);
            checkMemoryWarning(mergeableFiles, 'advancedMergeWarning');

            document.getElementById('advancedMergeModal').classList.add('active');
            document.getElementById('pageCount').textContent = advancedMerger?.pages?.length || 0;
        }

        function closeAdvancedSort() {
            const modal = document.getElementById('advancedMergeModal');
            modal.classList.remove('active');
        }

        function resetPageOrder() {
            if (advancedMerger) {
                advancedMerger.resetOrder();
            }
        }

        function isCompressEnabledForMode(mode, fallback = true) {
            const toggle = document.getElementById(`${mode}CompressToggle`);
            return toggle ? toggle.checked : fallback;
        }

        function isMoreCompressEnabledForMode(mode) {
            const toggle = document.getElementById(`${mode}RasterToggle`);
            return toggle ? toggle.checked : false;
        }

        function getRasterSettingsForMode(mode) {
            const scaleInput = document.getElementById(`${mode}RasterScale`);
            const qualityInput = document.getElementById(`${mode}RasterQuality`);
            const scale = scaleInput ? parseFloat(scaleInput.value) : 1.0;
            const quality = qualityInput ? parseFloat(qualityInput.value) : 0.6;
            return {
                scale: Number.isFinite(scale) ? scale : 1.0,
                quality: Number.isFinite(quality) ? quality : 0.6
            };
        }

        function updateRasterValue(mode) {
            const qualityInput = document.getElementById(`${mode}RasterQuality`);
            const qualityValue = document.getElementById(`${mode}RasterQualityValue`);
            if (qualityInput && qualityValue) {
                qualityValue.textContent = `${Math.round(parseFloat(qualityInput.value) * 100)}%`;
            }
            const scaleInput = document.getElementById(`${mode}RasterScale`);
            const scaleValue = document.getElementById(`${mode}RasterScaleValue`);
            if (scaleInput && scaleValue) {
                scaleValue.textContent = `${Math.round(parseFloat(scaleInput.value) * 100)}%`;
            }
        }

        function isAdvancedCompressionEnabled() {
            const toggle = document.getElementById('advancedCompressionToggle');
            return toggle ? toggle.checked : false;
        }

        function getAdvancedCompressionMode() {
            if (!isAdvancedCompressionEnabled()) return 'none';
            const selected = document.querySelector('input[name="advancedCompressionMode"]:checked');
            return selected ? selected.value : 'standard';
        }

        function updateAdvancedCompressionToggleLabel() {
            const toggle = document.getElementById('advancedCompressionToggle');
            const label = document.querySelector('label[for="advancedCompressionToggle"]');
            if (!toggle || !label) return;
            const enabled = toggle.checked;
            label.textContent = enabled ? 'Compression On' : 'Compression Off';
            label.classList.toggle('is-on', enabled);
        }

        function updateAdvancedCompressionSettings() {
            const settings = document.getElementById('advancedRasterSettings');
            const options = document.getElementById('advancedCompressionOptions');
            if (!settings || !options) return;
            const enabled = isAdvancedCompressionEnabled();
            options.classList.toggle('active', enabled);
            options.querySelectorAll('input').forEach((input) => {
                input.disabled = !enabled;
            });
            const showSettings = enabled && getAdvancedCompressionMode() === 'images';
            settings.classList.toggle('active', showSettings);
            settings.querySelectorAll('input').forEach((input) => {
                input.disabled = !showSettings;
            });
            updateRasterValue('advanced');
        }

        function setupAdvancedCompressionControls() {
            updateAdvancedCompressionToggleLabel();
            updateAdvancedCompressionSettings();
            const toggle = document.getElementById('advancedCompressionToggle');
            if (toggle) {
                toggle.addEventListener('change', () => {
                    updateAdvancedCompressionToggleLabel();
                    updateAdvancedCompressionSettings();
                });
            }
            document.querySelectorAll('input[name="advancedCompressionMode"]').forEach((input) => {
                input.addEventListener('change', updateAdvancedCompressionSettings);
            });
            const qualityInput = document.getElementById('advancedRasterQuality');
            const scaleInput = document.getElementById('advancedRasterScale');
            if (qualityInput) {
                qualityInput.addEventListener('input', () => updateRasterValue('advanced'));
            }
            if (scaleInput) {
                scaleInput.addEventListener('input', () => updateRasterValue('advanced'));
            }
        }

        function isAdvancedCompressEnabled() {
            return isAdvancedCompressionEnabled();
        }

        function isAdvancedMoreCompressEnabled() {
            return isAdvancedCompressionEnabled() && getAdvancedCompressionMode() === 'images';
        }

        function getAdvancedRasterSettings() {
            return getRasterSettingsForMode('advanced');
        }

        function dataUrlToUint8Array(dataUrl) {
            const base64 = (dataUrl || '').split(',')[1] || '';
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        async function renderPdfJsPageToJpegBytes(page, settings) {
            const viewport = page.getViewport({ scale: settings.scale });
            const canvas = document.createElement('canvas');
            canvas.width = Math.floor(viewport.width);
            canvas.height = Math.floor(viewport.height);
            const context = canvas.getContext('2d');
            if (!context) {
                throw new Error('Could not get canvas context');
            }
            const renderTask = page.render({ canvasContext: context, viewport });
            await renderTask.promise;
            const dataUrl = canvas.toDataURL('image/jpeg', settings.quality);
            return {
                bytes: dataUrlToUint8Array(dataUrl),
                width: viewport.width,
                height: viewport.height
            };
        }

        async function renderPageToJpegBytes(pageData, settings) {
            if (!pageData || !pageData.pdfDoc) {
                throw new Error('Page source not available for compression');
            }
            const page = await pageData.pdfDoc.getPage(pageData.pageIndex + 1);
            return renderPdfJsPageToJpegBytes(page, settings);
        }

        const IMAGE_HEAVY_TEXT_CHARS = 80;
        const IMAGE_HEAVY_TEXT_ITEMS = 12;

        function getImageOpSet() {
            if (typeof pdfjsLib === 'undefined' || !pdfjsLib.OPS) return new Set();
            const ops = pdfjsLib.OPS;
            return new Set([
                ops.paintImageXObject,
                ops.paintJpegXObject,
                ops.paintImageMaskXObject,
                ops.paintInlineImageXObject,
                ops.paintInlineImageXObjectGroup
            ].filter((value) => typeof value === 'number'));
        }

        async function isImageHeavyPdfJsPage(page) {
            try {
                const [textContent, opList] = await Promise.all([
                    page.getTextContent(),
                    page.getOperatorList()
                ]);
                const items = textContent.items || [];
                const textChars = items.reduce((sum, item) => {
                    const text = item?.str || '';
                    return sum + text.trim().length;
                }, 0);
                const textItems = items.length;
                const imageOps = getImageOpSet();
                const imageCount = (opList.fnArray || []).reduce((sum, op) => {
                    return sum + (imageOps.has(op) ? 1 : 0);
                }, 0);
                return imageCount > 0 && textChars <= IMAGE_HEAVY_TEXT_CHARS && textItems <= IMAGE_HEAVY_TEXT_ITEMS;
            } catch (error) {
                return false;
            }
        }

        function ensurePdfJsWorker() {
            if (typeof pdfjsLib === 'undefined' || !pdfjsLib.GlobalWorkerOptions) return;
            if (!pdfjsLib.GlobalWorkerOptions.workerSrc) {
                pdfjsLib.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js';
            }
        }

        async function finalizeAdvancedMerge() {
            if (!advancedMerger) return;

            const orderedPages = advancedMerger.getPageOrder();
            closeAdvancedSort();
            await mergeWithCustomOrder(orderedPages);
        }

        async function mergeWithCustomOrder(orderedPages) {
            const customFilename = document.getElementById('customFilename').value.trim() || 'merged.pdf';
            const filename = customFilename.endsWith('.pdf') ? customFilename : customFilename + '.pdf';
            const mergeStart = performance.now();
            const compressEnabled = isAdvancedCompressEnabled();
            const moreCompressEnabled = isAdvancedMoreCompressEnabled();
            const useObjectStreams = compressEnabled || moreCompressEnabled;
            const mergeFiles = advancedMergerFiles && advancedMergerFiles.length ? advancedMergerFiles : getMergeableFiles(expandedFiles);
            const stats = getFileStats(mergeFiles);
            const skippedFileIndices = new Set();
            let skippedCount = 0;
            let rasterizedPages = 0;
            let compressionNote = '';
            mergeInProgress = true;
            
            const btn = document.getElementById('expandedMergeBtn');
            btn.classList.add('loading');
            btn.disabled = true;

            // Stop thumbnail rendering to prioritize merge
            if (advancedMerger && typeof advancedMerger.cancelThumbnailRendering === 'function') {
                advancedMerger.cancelThumbnailRendering();
            }

            const statusElement = document.getElementById('expandedStatus') || 
                                document.createElement('div');
            
            if (!statusElement.id) {
                statusElement.id = 'expandedStatus';
                statusElement.className = 'status-area status-processing';
                document.querySelector('.mode-expanded').appendChild(statusElement);
            }

            statusElement.className = 'status-area status-processing';
            statusElement.innerHTML = '<span>‚è≥ Merging with custom order...</span>';
            if (moreCompressEnabled) {
                statusElement.innerHTML = '<span>Compressing pages...</span>';
            }

            try {
                if (mergeFiles.length < 2) {
                    statusElement.className = 'status-area status-error';
                    statusElement.innerHTML = '<span>Select at least 2 mergeable PDFs.</span>';
                    return;
                }
                if (isMergeTooLarge(stats)) {
                    statusElement.className = 'status-area status-error';
                    statusElement.innerHTML = '<span>' + buildMergeTooLargeMessage(stats) + '</span>';
                    return;
                }
                const pdfDoc = await PDFLib.PDFDocument.create();
                if (hasKnownEncryptedFile(mergeFiles)) {
                    statusElement.className = 'status-area status-error';
                    statusElement.innerHTML = '<span>üîí Locked PDF. Unlock to merge.</span>';
                    return;
                }
                if (moreCompressEnabled) {
                    const rasterSettings = getAdvancedRasterSettings();
                    const totalPages = orderedPages.length;
                    const loadedPdfs = new Map();
                    ensurePdfJsWorker();

                    for (let i = 0; i < orderedPages.length; i++) {
                        const pageData = orderedPages[i];
                        const fileIndex = pageData.fileIndex;
                        if (skippedFileIndices.has(fileIndex)) continue;

                        const file = mergeFiles[fileIndex];
                        if (!file) {
                            skippedFileIndices.add(fileIndex);
                            skippedCount += 1;
                            continue;
                        }

                        let pdfJsPage = null;
                        try {
                            pdfJsPage = await pageData.pdfDoc.getPage(pageData.pageIndex + 1);
                        } catch (error) {
                            const shouldSkip = promptSkipFile(file, error);
                            if (shouldSkip) {
                                skippedFileIndices.add(fileIndex);
                                skippedCount += 1;
                                markFileIssue(file, 'Skipped due to read error');
                                renderPdfList();
                                updateDocCount();
                                updateExpandedMergeButton();
                                reportMergeError(error, {
                                    mode: 'advanced_sorted',
                                    step: 'mergeWithCustomOrder-rasterize-skip',
                                    fileCount: mergeFiles?.length || 0,
                                    pageCount: orderedPages?.length || 0,
                                    totalBytes: stats.totalBytes,
                                    maxBytes: stats.maxBytes,
                                    durationMs: performance.now() - mergeStart,
                                    source: 'pdfjs-raster',
                                    userNote: `user_action=skip;fileIndex=${fileIndex}`
                                });
                                continue;
                            }
                            throw error;
                        }

                        const shouldRasterize = await isImageHeavyPdfJsPage(pdfJsPage);

                        if (shouldRasterize) {
                            try {
                                const raster = await renderPdfJsPageToJpegBytes(pdfJsPage, rasterSettings);
                                const image = await pdfDoc.embedJpg(raster.bytes);
                                const page = pdfDoc.addPage([raster.width, raster.height]);
                                page.drawImage(image, {
                                    x: 0,
                                    y: 0,
                                    width: raster.width,
                                    height: raster.height
                                });
                                rasterizedPages += 1;
                            } catch (error) {
                                const shouldSkip = promptSkipFile(file, error);
                                if (shouldSkip) {
                                    skippedFileIndices.add(fileIndex);
                                    skippedCount += 1;
                                    markFileIssue(file, 'Skipped due to read error');
                                    renderPdfList();
                                    updateDocCount();
                                    updateExpandedMergeButton();
                                    reportMergeError(error, {
                                        mode: 'advanced_sorted',
                                        step: 'mergeWithCustomOrder-rasterize-skip',
                                        fileCount: mergeFiles?.length || 0,
                                        pageCount: orderedPages?.length || 0,
                                        totalBytes: stats.totalBytes,
                                        maxBytes: stats.maxBytes,
                                        durationMs: performance.now() - mergeStart,
                                        source: 'pdfjs-raster',
                                        userNote: `user_action=skip;fileIndex=${fileIndex}`
                                    });
                                    continue;
                                }
                                throw error;
                            }
                        } else {
                            if (!loadedPdfs.has(fileIndex)) {
                                try {
                                    const arrayBuffer = await file.arrayBuffer();
                                    const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
                                    loadedPdfs.set(fileIndex, pdf);
                                } catch (error) {
                                    const shouldSkip = promptSkipFile(file, error);
                                    if (shouldSkip) {
                                        skippedFileIndices.add(fileIndex);
                                        skippedCount += 1;
                                        markFileIssue(file, 'Skipped due to read error');
                                        renderPdfList();
                                        updateDocCount();
                                        updateExpandedMergeButton();
                                        reportMergeError(error, {
                                            mode: 'advanced_sorted',
                                            step: 'mergeWithCustomOrder-skip',
                                            fileCount: mergeFiles?.length || 0,
                                            pageCount: orderedPages?.length || 0,
                                            totalBytes: stats.totalBytes,
                                            maxBytes: stats.maxBytes,
                                            durationMs: performance.now() - mergeStart,
                                            source: 'pdf-lib',
                                            userNote: `user_action=skip;fileIndex=${fileIndex}`
                                        });
                                        continue;
                                    }
                                    throw error;
                                }
                            }

                            if (skippedFileIndices.has(fileIndex)) continue;

                            try {
                                const sourcePdf = loadedPdfs.get(fileIndex);
                                if (!sourcePdf) continue;
                                const copiedPages = await pdfDoc.copyPages(sourcePdf, [pageData.pageIndex]);
                                copiedPages.forEach((page) => {
                                    pdfDoc.addPage(page);
                                });
                            } catch (error) {
                                const shouldSkip = promptSkipFile(file, error);
                                if (shouldSkip) {
                                    skippedFileIndices.add(fileIndex);
                                    skippedCount += 1;
                                    markFileIssue(file, 'Skipped due to read error');
                                    renderPdfList();
                                    updateDocCount();
                                    updateExpandedMergeButton();
                                    reportMergeError(error, {
                                        mode: 'advanced_sorted',
                                        step: 'mergeWithCustomOrder-skip',
                                        fileCount: mergeFiles?.length || 0,
                                        pageCount: orderedPages?.length || 0,
                                        totalBytes: stats.totalBytes,
                                        maxBytes: stats.maxBytes,
                                        durationMs: performance.now() - mergeStart,
                                        source: 'pdf-lib',
                                        userNote: `user_action=skip;fileIndex=${fileIndex}`
                                    });
                                    continue;
                                }
                                throw error;
                            }
                        }

                        if ((i + 1) % 10 === 0 || i === totalPages - 1) {
                            statusElement.innerHTML = '<span>Compressing pages... ' + (i + 1) + '/' + totalPages + '</span>';
                        }
                    }

                    if (rasterizedPages === 0) {
                        compressionNote = 'Note: No image-heavy pages found; compression is minimal.';
                    }
                } else {
                    const loadedPdfs = new Map();

                    for (const pageData of orderedPages) {
                        const fileIndex = pageData.fileIndex;
                        if (skippedFileIndices.has(fileIndex)) continue;

                        const file = mergeFiles[fileIndex];
                        if (!file) {
                            skippedFileIndices.add(fileIndex);
                            skippedCount += 1;
                            continue;
                        }

                        if (!loadedPdfs.has(fileIndex)) {
                            try {
                                const arrayBuffer = await file.arrayBuffer();
                                const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
                                loadedPdfs.set(fileIndex, pdf);
                            } catch (error) {
                                const shouldSkip = promptSkipFile(file, error);
                                if (shouldSkip) {
                                    skippedFileIndices.add(fileIndex);
                                    skippedCount += 1;
                                    markFileIssue(file, 'Skipped due to read error');
                                    renderPdfList();
                                    updateDocCount();
                                    updateExpandedMergeButton();
                                    reportMergeError(error, {
                                        mode: 'advanced_sorted',
                                        step: 'mergeWithCustomOrder-skip',
                                        fileCount: mergeFiles?.length || 0,
                                        pageCount: orderedPages?.length || 0,
                                        totalBytes: stats.totalBytes,
                                        maxBytes: stats.maxBytes,
                                        durationMs: performance.now() - mergeStart,
                                        source: 'pdf-lib',
                                        userNote: `user_action=skip;fileIndex=${fileIndex}`
                                    });
                                    continue;
                                }
                                throw error;
                            }
                        }

                        if (skippedFileIndices.has(fileIndex)) continue;

                        try {
                            const sourcePdf = loadedPdfs.get(fileIndex);
                            if (!sourcePdf) continue;
                            const copiedPages = await pdfDoc.copyPages(sourcePdf, [pageData.pageIndex]);
                            
                            copiedPages.forEach((page) => {
                                pdfDoc.addPage(page);
                            });
                        } catch (error) {
                            const shouldSkip = promptSkipFile(file, error);
                            if (shouldSkip) {
                                skippedFileIndices.add(fileIndex);
                                skippedCount += 1;
                                markFileIssue(file, 'Skipped due to read error');
                                renderPdfList();
                                updateDocCount();
                                updateExpandedMergeButton();
                                reportMergeError(error, {
                                    mode: 'advanced_sorted',
                                    step: 'mergeWithCustomOrder-skip',
                                    fileCount: mergeFiles?.length || 0,
                                    pageCount: orderedPages?.length || 0,
                                    totalBytes: stats.totalBytes,
                                    maxBytes: stats.maxBytes,
                                    durationMs: performance.now() - mergeStart,
                                    source: 'pdf-lib',
                                    userNote: `user_action=skip;fileIndex=${fileIndex}`
                                });
                                continue;
                            }
                            throw error;
                        }
                    }
                }

                if (pdfDoc.getPageCount() === 0) {
                    statusElement.className = 'status-area status-error';
                    statusElement.innerHTML = '<span>No mergeable pages were left after skipping files.</span>';
                    return;
                }

                if (pdfDoc.getPageCount() === 0) {
                    const msg = 'No mergeable pages were left after skipping files.';
                    showError(msg, isExpanded ? 'expandedError' : 'simpleError');
                    if (statusElement) {
                        statusElement.className = 'status-area status-error';
                        statusElement.innerHTML = '<span>' + msg + '</span>';
                    }
                    return;
                }

                const pdfBytes = await pdfDoc.save({ useObjectStreams });
                downloadPDF(pdfBytes, filename);

                const successMsg = skippedCount > 0
                    ? `Merged with ${skippedCount} skipped file${skippedCount !== 1 ? 's' : ''}. Download started.`
                    : 'Success! Download started.';
                statusElement.className = 'status-area status-success';
                const noteText = compressionNote ? ' ' + compressionNote : '';
                statusElement.innerHTML = '<span>' + successMsg + noteText + getAffiliateInlineHtml() + '</span>';

                if (typeof gtag !== 'undefined') {
                    gtag('event', 'pdf_merge_success', {
                        'mode': 'advanced_sorted',
                        'file_count': mergeFiles.length,
                        'page_count': pdfDoc.getPageCount()
                    });
                }
            } catch (error) {
                const isEncrypted = isEncryptedPdfError(error);
                const isMemory = isMemoryError(error);
                const isFileRead = isFileReadError(error);
                let friendlyMsg = `Error: ${error.message}`;
                if (isEncrypted) {
                    friendlyMsg = 'Locked PDF. Unlock to merge.';
                } else if (isMemory) {
                    friendlyMsg = 'The merge ran out of memory. Try fewer or smaller PDFs.';
                } else if (isFileRead) {
                    friendlyMsg = 'Could not read one of the files. It may have been moved, renamed, or is in a sync/network folder. Copy it locally and reselect.';
                }
                statusElement.className = 'status-area status-error';
                statusElement.innerHTML = '<span>' + friendlyMsg + '</span>';

                if (typeof gtag !== 'undefined') {
                    gtag('event', 'pdf_merge_error', {
                        'mode': 'advanced_sorted',
                        'error_message': error.message
                    });
                }

                console.error('Merge error:', error);
                reportMergeError(error, {
                    mode: 'advanced_sorted',
                    step: 'mergeWithCustomOrder',
                    fileCount: mergeFiles?.length || 0,
                    pageCount: orderedPages?.length || 0,
                    totalBytes: stats.totalBytes,
                    maxBytes: stats.maxBytes,
                    durationMs: performance.now() - mergeStart,
                    source: 'pdf-lib'
                });
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
                mergeInProgress = false;
            }
        }

        // ===== MERGE FUNCTION =====
        async function mergePDFs() {
          const mergeStart = performance.now();
          let stats = { totalBytes: 0, maxBytes: 0, fileCount: 0 };
          mergeInProgress = true;
          try {
            const isExpanded = document.getElementById('expandedMode').classList.contains('active');
            const pdfLibOk = await ensurePdfLibReadyWithRetry();
            if (!pdfLibOk) {
                showError('PDF engine failed to load. Refresh the page.', isExpanded ? 'expandedError' : 'simpleError');
                mergeInProgress = false;
                return;
            }
            const allFiles = isExpanded 
                ? expandedFiles 
                : [document.getElementById('file1').files[0], document.getElementById('file2').files[0]].filter(Boolean);
            const files = getMergeableFiles(allFiles);

            if (files.length < 2) {
                showError('Select at least 2 mergeable PDFs.', isExpanded ? 'expandedError' : 'simpleError');
                mergeInProgress = false;
                return;
            }

            // Stop any background thumbnail rendering to prioritize merge
            if (advancedMerger && typeof advancedMerger.cancelThumbnailRendering === 'function') {
                advancedMerger.cancelThumbnailRendering();
            }

            const btn = isExpanded ? document.getElementById('expandedMergeBtn') : document.getElementById('simpleMergeBtn');
            btn.classList.add('loading');
            btn.disabled = true;

            const statusElement = isExpanded
                ? document.getElementById('expandedStatus') || document.createElement('div')
                : document.getElementById('simpleStatus');
            if (isExpanded && statusElement && !statusElement.id) {
                statusElement.id = 'expandedStatus';
                statusElement.className = 'status-area status-processing';
                document.querySelector('.mode-expanded').appendChild(statusElement);
            }
            if (statusElement) {
                statusElement.className = 'status-area status-processing';
                statusElement.innerHTML = '<span>‚è≥ Processing...</span>';
            }

            try {
                let skippedCount = 0;
                let compressionNote = '';
                stats = getFileStats(files);
                const modeKey = isExpanded ? 'expanded' : 'simple';
                const compressEnabled = isCompressEnabledForMode(modeKey, true);
                const moreCompressEnabled = isMoreCompressEnabledForMode(modeKey);
                const useObjectStreams = compressEnabled || moreCompressEnabled;
                const rasterSettings = getRasterSettingsForMode(modeKey);
                if (statusElement && moreCompressEnabled) {
                    statusElement.className = 'status-area status-processing';
                    statusElement.innerHTML = '<span>Compressing pages...</span>';
                }
                // Generate filename based on mode and input
                let filename;
                if (isExpanded) {
                    const input = document.getElementById('expandedFilename');
                    filename = getFinalFilename(input ? input.value : '', files);
                } else {
                    const input = document.getElementById('simpleFilename');
                    filename = getFinalFilename(input ? input.value : '', files);
                }
                
                if (isMergeTooLarge(stats)) {
                    const msg = buildMergeTooLargeMessage(stats);
                    showError(msg, isExpanded ? 'expandedError' : 'simpleError');
                    if (statusElement) {
                        statusElement.className = 'status-area status-error';
                        statusElement.innerHTML = '<span>' + msg + '</span>';
                    }
                    return;
                }
                const pdfDoc = await PDFLib.PDFDocument.create();
                if (hasKnownEncryptedFile(files)) {
                    const msg = 'Locked PDF. Unlock to merge.';
                    showError(msg, isExpanded ? 'expandedError' : 'simpleError');
                    if (statusElement) {
                        statusElement.className = 'status-area status-error';
                        statusElement.innerHTML = '<span>üîí Locked PDF. Unlock to merge.</span>';
                    }
                    return;
                }

                if (moreCompressEnabled) {
                    let processedPages = 0;
                    let totalPages = 0;
                    let rasterizedCount = 0;
                    ensurePdfJsWorker();

                    for (const file of files) {
                        let pdfJsDoc = null;
                        let pdfLibDoc = null;
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            pdfJsDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                            pdfLibDoc = await PDFLib.PDFDocument.load(arrayBuffer);
                            totalPages += pdfJsDoc.numPages;
                        } catch (error) {
                            const shouldSkip = promptSkipFile(file, error);
                            if (shouldSkip) {
                                skippedCount += 1;
                                markFileIssue(file, 'Skipped due to read error');
                                if (isExpanded) {
                                    renderPdfList();
                                    updateDocCount();
                                    updateExpandedMergeButton();
                                }
                                reportMergeError(error, {
                                    mode: isExpanded ? 'expanded' : 'simple',
                                    step: 'mergePDFs-rasterize-skip',
                                    fileCount: files?.length || 0,
                                    totalBytes: stats.totalBytes,
                                    maxBytes: stats.maxBytes,
                                    durationMs: performance.now() - mergeStart,
                                    source: 'pdfjs-raster',
                                    userNote: 'user_action=skip'
                                });
                                continue;
                            }
                            throw error;
                        }

                        let skipCurrentFile = false;
                        for (let pageIndex = 0; pageIndex < pdfJsDoc.numPages; pageIndex++) {
                            let page = null;
                            try {
                                page = await pdfJsDoc.getPage(pageIndex + 1);
                                const shouldRasterize = await isImageHeavyPdfJsPage(page);
                                if (shouldRasterize) {
                                    const raster = await renderPdfJsPageToJpegBytes(page, rasterSettings);
                                    const image = await pdfDoc.embedJpg(raster.bytes);
                                    const newPage = pdfDoc.addPage([raster.width, raster.height]);
                                    newPage.drawImage(image, {
                                        x: 0,
                                        y: 0,
                                        width: raster.width,
                                        height: raster.height
                                    });
                                    rasterizedCount += 1;
                                } else {
                                    const copiedPages = await pdfDoc.copyPages(pdfLibDoc, [pageIndex]);
                                    copiedPages.forEach((copiedPage) => {
                                        pdfDoc.addPage(copiedPage);
                                    });
                                }
                            } catch (error) {
                                const shouldSkip = promptSkipFile(file, error);
                                if (shouldSkip) {
                                    skippedCount += 1;
                                    markFileIssue(file, 'Skipped due to read error');
                                    if (isExpanded) {
                                        renderPdfList();
                                        updateDocCount();
                                        updateExpandedMergeButton();
                                    }
                                    reportMergeError(error, {
                                        mode: isExpanded ? 'expanded' : 'simple',
                                        step: 'mergePDFs-rasterize-skip',
                                        fileCount: files?.length || 0,
                                        totalBytes: stats.totalBytes,
                                        maxBytes: stats.maxBytes,
                                        durationMs: performance.now() - mergeStart,
                                        source: 'pdfjs-raster',
                                        userNote: 'user_action=skip'
                                    });
                                    skipCurrentFile = true;
                                    break;
                                }
                                throw error;
                            } finally {
                                processedPages += 1;
                                if (statusElement && totalPages > 0 && (processedPages % 10 === 0 || processedPages === totalPages)) {
                                    statusElement.innerHTML = '<span>Compressing pages... ' + processedPages + '/' + totalPages + '</span>';
                                }
                            }
                        }

                        if (typeof pdfJsDoc?.cleanup === 'function') {
                            pdfJsDoc.cleanup();
                        }
                        if (typeof pdfJsDoc?.destroy === 'function') {
                            pdfJsDoc.destroy();
                        }

                        if (skipCurrentFile) {
                            continue;
                        }
                    }

                    if (rasterizedCount === 0) {
                        compressionNote = 'Note: No image-heavy pages found; compression is minimal.';
                    }
                } else {
                    for (const file of files) {
                        try {
                            const arrayBuffer = await file.arrayBuffer();
                            const pdf = await PDFLib.PDFDocument.load(arrayBuffer);
                            const copiedPages = await pdfDoc.copyPages(pdf, pdf.getPageIndices());
                            copiedPages.forEach((page) => {
                                pdfDoc.addPage(page);
                            });
                        } catch (error) {
                            const shouldSkip = promptSkipFile(file, error);
                            if (shouldSkip) {
                                skippedCount += 1;
                                markFileIssue(file, 'Skipped due to read error');
                                if (isExpanded) {
                                    renderPdfList();
                                    updateDocCount();
                                    updateExpandedMergeButton();
                                }
                                reportMergeError(error, {
                                    mode: isExpanded ? 'expanded' : 'simple',
                                    step: 'mergePDFs-skip',
                                    fileCount: files?.length || 0,
                                    totalBytes: stats.totalBytes,
                                    maxBytes: stats.maxBytes,
                                    durationMs: performance.now() - mergeStart,
                                    source: 'pdf-lib',
                                    userNote: 'user_action=skip'
                                });
                                continue;
                            }
                            throw error;
                        }
                    }
                }

                const pdfBytes = await pdfDoc.save({ useObjectStreams });
                downloadPDF(pdfBytes, filename);

                if (statusElement) {
                    const successMsg = skippedCount > 0
                        ? `Merged with ${skippedCount} skipped file${skippedCount !== 1 ? 's' : ''}. Download started.`
                        : 'Success! Download started.';
                    statusElement.className = 'status-area status-success';
                    const noteText = compressionNote ? ' ' + compressionNote : '';
                    statusElement.innerHTML = '<span>' + successMsg + noteText + getAffiliateInlineHtml() + '</span>';
                }

                if (typeof gtag !== 'undefined') {
                    gtag('event', 'pdf_merge_success', {
                        'mode': isExpanded ? 'expanded' : 'simple',
                        'file_count': files.length,
                        'page_count': pdfDoc.getPageCount()
                    });
                }
            } catch (error) {
                const friendlyMsg = buildMergeFailureMessage(error, {
                    fileCount: files?.length || 0,
                    totalBytes: stats.totalBytes
                }, isExpanded ? 'expanded' : 'simple');

                reportMergeError(error, {
                    mode: isExpanded ? 'expanded' : 'simple',
                    step: 'mergePDFs',
                    fileCount: files?.length || 0,
                    totalBytes: stats.totalBytes,
                    maxBytes: stats.maxBytes,
                    durationMs: performance.now() - mergeStart,
                    source: 'pdf-lib'
                });
                showError(friendlyMsg, isExpanded ? 'expandedError' : 'simpleError');
                
                if (statusElement) {
                    statusElement.className = 'status-area status-error';
                    statusElement.innerHTML = '<span>' + friendlyMsg + '</span>';
                }

                if (typeof gtag !== 'undefined') {
                    gtag('event', 'pdf_merge_error', {
                        'mode': isExpanded ? 'expanded' : 'simple',
                        'error_message': error.message
                    });
                }
            } finally {
                btn.classList.remove('loading');
                btn.disabled = false;
                mergeInProgress = false;
            }
          } catch (error) {
            mergeInProgress = false;
            reportMergeError(error, {
              mode: 'unknown',
              step: 'mergePDFs-outer',
              fileCount: stats?.fileCount || 0,
              totalBytes: stats?.totalBytes || 0,
              maxBytes: stats?.maxBytes || 0,
              durationMs: performance.now() - mergeStart,
              source: 'pdf-lib'
            });
            gtag('event', 'pdf_merge_failed', {
              error_message: error?.message || 'Unknown error',
              error_type: error?.name || 'Error',
              timestamp: new Date().toISOString()
            });
            
            console.error('Merge failed:', error);
            alert('Merge failed: ' + (error?.message || 'Unknown error'));
            throw error;
          }
        }

        function isEncryptedPdfError(err) {
            const msg = `${err?.name || ''} ${err?.message || ''}`.toLowerCase();
            return msg.includes('encrypted') ||
                msg.includes('password-protected') ||
                msg.includes('password protected') ||
                msg.includes('no password') ||
                msg.includes('password required') ||
                msg.includes('password');
        }

        function isFileReadError(err) {
            const text = `${err?.name || ''} ${err?.message || ''}`.toLowerCase();
            return text.includes('notreadableerror') ||
                text.includes('could not be read') ||
                text.includes('permission') ||
                text.includes('securityerror') ||
                text.includes('notfounderror') ||
                text.includes('could not be found') ||
                text.includes('not found');
        }

        function isMemoryError(err) {
            const text = `${err?.name || ''} ${err?.message || ''}`.toLowerCase();
            return text.includes('array buffer allocation failed') ||
                text.includes('out of memory') ||
                text.includes('rangeerror');
        }

        function isCorruptPdfError(err) {
            const text = `${err?.name || ''} ${err?.message || ''}`.toLowerCase();
            return text.includes('invalid pdf structure') ||
                text.includes('no pdf header') ||
                text.includes('failed to parse') ||
                text.includes('xref') ||
                text.includes('corrupt');
        }

        function buildMergeFailureMessage(error, stats = {}, mode = 'simple') {
            const isEncrypted = isEncryptedPdfError(error);
            const isMemory = isMemoryError(error);
            const isFileRead = isFileReadError(error);
            const isCorrupt = isCorruptPdfError(error);
            const fileCount = Number.isFinite(stats?.fileCount) ? stats.fileCount : null;
            const totalBytes = Number.isFinite(stats?.totalBytes) ? stats.totalBytes : null;
            const sizeHint = totalBytes ? ` (${formatFileSize(totalBytes)})` : '';

            if (isEncrypted) {
                return 'Locked PDF. Unlock and try again.';
            }
            if (isCorrupt) {
                return 'Not a valid PDF. Try another file.';
            }
            if (isMemory) {
                return `Too large to merge${sizeHint}. Try fewer files/pages.`;
            }
            if (isFileRead) {
                return "Can't read a file. Re-select files.";
            }
            const countNote = fileCount ? ` (${fileCount} files)` : '';
            return `Merge failed${countNote}. Try again.`;
        }

        function reportMergeError(err, meta = {}) {
            if (typeof window.reportError !== 'function') return;
            try {
                const throttles = window.__MERGE_ERROR_THROTTLE || (window.__MERGE_ERROR_THROTTLE = {});
                const key = `${meta.mode || 'n/a'}|${meta.step || 'n/a'}|${err?.message || ''}`;
                const now = Date.now();
                const last = throttles[key] || 0;
                if (now - last < 2000) return; // throttle duplicates within 2s
                throttles[key] = now;

                const note = [
                    `mode=${meta.mode || 'n/a'}`,
                    `step=${meta.step || 'n/a'}`,
                    `files=${Number.isFinite(meta.fileCount) ? meta.fileCount : 'n/a'}`,
                    typeof meta.pageCount === 'number' ? `pages=${meta.pageCount}` : null,
                    `error=${err?.name || 'Error'}`,
                    `source=${meta.source || detectErrorSource(err)}`,
                    Number.isFinite(meta.totalBytes) ? `totalBytes=${meta.totalBytes}` : null,
                    Number.isFinite(meta.maxBytes) ? `maxBytes=${meta.maxBytes}` : null,
                    Number.isFinite(meta.durationMs) ? `durationMs=${Math.round(meta.durationMs)}` : null,
                    meta.libraryVersion ? `libVer=${meta.libraryVersion}` : null
                ].filter(Boolean).join(';');

                window.reportError(err, {
                    feature: 'pdf_merge',
                    userNote: note
                });
            } catch (reportErr) {
                console.warn('reportMergeError failed', reportErr);
            }
        }

        function detectErrorSource(err) {
            const txt = `${err?.stack || ''} ${err?.message || ''}`.toLowerCase();
            if (txt.includes('pdf-lib')) return 'pdf-lib';
            if (txt.includes('pdfjs') || txt.includes('pdf.js')) return 'pdf.js';
            return 'unknown';
        }

        function getFileStats(files = []) {
            try {
                const list = Array.from(files || []).filter(Boolean);
                const totalBytes = list.reduce((sum, f) => sum + (typeof f.size === 'number' ? f.size : 0), 0);
                const maxBytes = list.reduce((max, f) => {
                    const size = typeof f.size === 'number' ? f.size : 0;
                    return size > max ? size : max;
                }, 0);
                return { totalBytes, maxBytes, fileCount: list.length };
            } catch (e) {
                return { totalBytes: 0, maxBytes: 0, fileCount: 0 };
            }
        }

        function isMergeTooLarge(stats) {
            return Number.isFinite(stats?.totalBytes) && stats.totalBytes > MERGE_HARD_LIMIT_BYTES;
        }

        function buildMergeTooLargeMessage(stats) {
            const total = formatFileSize(stats?.totalBytes || 0);
            return `Total file size (${total}) is too large to merge in the browser. Try fewer or smaller PDFs.`;
        }

        async function hasPdfHeader(file) {
            try {
                const header = await file.slice(0, 5).arrayBuffer();
                const text = new TextDecoder('ascii').decode(header);
                return text.startsWith('%PDF-');
            } catch (e) {
                return false;
            }
        }

        function queueEncryptionScan(file, targetId, mode, inputId) {
            if (!file || mergeInProgress) return;
            if (encryptionScanResults.has(file)) return;

            setTimeout(async () => {
                if (mergeInProgress) return;
                const isEncrypted = await scanEncryptedPdf(file);
                encryptionScanResults.set(file, isEncrypted);
                if (!isEncrypted || mergeInProgress) return;

                if (mode === 'expanded' && !expandedFiles.includes(file)) return;
                if (mode === 'simple') {
                    const current = document.getElementById(inputId)?.files?.[0];
                    if (current !== file) return;
                }

                markFileIssue(file, 'Locked PDF');
                if (mode === 'expanded') {
                    renderPdfList();
                    updateDocCount();
                    updateExpandedMergeButton();
                    primeAdvancedMergeIfReady(expandedFiles);
                }
                if (encryptedWarningShown[mode]) return;
                encryptedWarningShown[mode] = true;
                showError('Locked PDF. Unlock to merge.', targetId);
            }, 0);
        }

        async function scanEncryptedPdf(file) {
            try {
                const first = await file.slice(0, ENCRYPTION_SCAN_BYTES).arrayBuffer();
                if (bufferHasEncrypt(first)) return true;
                if (file.size > ENCRYPTION_SCAN_BYTES) {
                    const start = Math.max(0, file.size - ENCRYPTION_SCAN_BYTES);
                    const last = await file.slice(start).arrayBuffer();
                    if (bufferHasEncrypt(last)) return true;
                }
            } catch (e) {
                return false;
            }
            return false;
        }

        function bufferHasEncrypt(buffer) {
            try {
                const text = new TextDecoder('ascii').decode(buffer);
                return text.includes('/Encrypt');
            } catch (e) {
                return false;
            }
        }

        function hasKnownEncryptedFile(files = []) {
            try {
                return Array.from(files || []).some((file) => file && encryptionScanResults.get(file) === true);
            } catch (e) {
                return false;
            }
        }

        function downloadPDF(pdfBytes, filename) {
            const blob = new Blob([pdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // ===== MODAL BACKDROP CLOSE =====
        document.addEventListener('DOMContentLoaded', () => {
            setupSimpleFileInputs();
            setupExpandedFileInputs();
            setupFilenameInputs();
            setupAdvancedCompressionControls();

            const modal = document.getElementById('advancedMergeModal');
            
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeAdvancedSort();
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeAdvancedSort();
                    }
                });
            }
        });
    </script>

    <!-- Sidebar feedback (for wide screens) - stays at bottom -->
    <!-- Button -->
    <button class="feedback-widget-button" id="feedbackButton" title="Send feedback">üí¨</button>
    
    <div class="feedback-overlay" id="feedbackOverlay"></div>
    
    <!-- Sidebar -->
    <div class="feedback-sidebar closed" id="feedbackSidebar">
        <div class="feedback-header">
            <h2 class="feedback-title">Help us improve</h2>
            <button class="feedback-close" id="feedbackCloseBtn">‚úï</button>
        </div>
        
        <div class="feedback-resize-handle" id="feedbackResizeHandle"></div>
        <div class="feedback-content">
            <p class="feedback-message">
                <strong>Your feedback matters.</strong> We read every message and use it to make this tool better for you.
            </p>
            
            <div class="feedback-error" id="feedbackError"></div>
            <div class="feedback-success" id="feedbackSuccess">
                <div class="feedback-success-icon">‚úì</div>
                <p class="feedback-success-text">Thank you! I'll read your message and improve the tool based on your feedback.</p>
            </div>
            
            <form class="feedback-form" id="feedbackForm">
                <input 
                    type="email" 
                    class="feedback-input" 
                    id="feedbackEmail" 
                    placeholder="your@email.com" 
                    required
                />

                <input
                    type="text"
                    class="feedback-input"
                    id="feedbackUserName"
                    placeholder="Your name (optional)"
                />
                
                <div class="feedback-message-row">
                    <textarea 
                        class="feedback-textarea feedback-input" 
                        id="feedbackMessage" 
                        placeholder="Tell me about bugs, feature ideas, or anything else..." 
                        required
                    ></textarea>

                    <button type="submit" class="feedback-button" id="feedbackSendBtn">
                        Send Feedback
                    </button>
                </div>

                <label class="feedback-toggle">
                    <input type="checkbox" id="feedbackPrivate" />
                    <span>Make this feedback private (won't be shown publicly)</span>
                </label>

                <div class="feedback-history" id="feedbackHistory">
                    <div class="feedback-history-heading">Recent feedback from users</div>
                    <ul class="feedback-history-list" id="feedbackHistoryList"></ul>
                    <div class="feedback-history-empty" id="feedbackHistoryEmpty">No feedback yet. Share your first note!</div>
                    <button type="button" class="feedback-show-toggle" id="feedbackShowToggle">Show more feedback</button>
                </div>
            </form>
        </div>
    </div>

    <script src="feedback.js"></script>
</body>
</html>


